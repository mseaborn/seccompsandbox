#include <dirent.h>
#include <map>

#include "sandbox_impl.h"
#include "syscall_table.h"

namespace playground {

struct Thread {
  int              fdPub, fd;
  SecureMem::Args* mem;
};

void Sandbox::trustedProcess(int processFdPub, int sandboxFd, int cloneFdPub,
                             int cloneFd) {
  SysCalls sys;
  std::map<pid_t, struct Thread> threads;

newThreadCreated:
  int     shmFd;
  pid_t   newTid;
  ssize_t newTidLen = sizeof(newTid);
  if (!getFd(cloneFd, &shmFd, NULL, &newTid, &newTidLen) ||
      newTidLen != sizeof(newTid)) {
    die("Failed to receive new thread information");
  }
  if (threads.count(newTid)) {
    die("Duplicate thread id");
  }
  Thread *newThread = &threads[newTid];
  newThread->mem    = reinterpret_cast<SecureMem::Args*>(
      mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, shmFd, 0));
  if (newThread->mem == MAP_FAILED) {
    die("Failed to set up shared memory for communicating with new thread");
  }
  /***/// TODO(markus): remove
  /***/char buf[80] = { 0 };
  /***/sprintf(buf, "/proc/self/fd/%d", shmFd);
  /***/readlink(buf, buf, sizeof(buf)-1);

  NOINTR_SYS(sys.close(shmFd));

  ssize_t selfLen = sizeof(void *);
  if (!getFd(cloneFd, &newThread->fdPub, &newThread->fd,
             &newThread->mem->self, &selfLen) ||
      selfLen != sizeof(void *)) {
    die("Failed to receive shared memory address from new thread");
  }
  write(sys, newThread->fdPub, "12345678", 8);

  /***/printf("Adding new thread %d, shm=%p \"%s\", fdPub=%d, fd=%d\n",
  /***/       newTid, newThread->mem, buf, newThread->fdPub, newThread->fd);

  // Dispatch system calls that have been forwarded from the trusted thread(s).
  for (;;) {
    struct {
      unsigned int sysnum;
      // TODO(markus): use a unique cookie (generated by trusted process) instead of tid
      pid_t        tid;
    } __attribute__((packed)) header;
    int rc;
    if ((rc = read(sys, sandboxFd, &header, sizeof(header))) !=sizeof(header)){
      if (rc) {
        die("Failed to read system call number and thread id");
      }
      die();
    }
    std::map<pid_t, struct Thread>::iterator iter = threads.find(header.tid);
    if (iter == threads.end()) {
      die("Received request from unknown thread");
    }
    if (header.sysnum > maxSyscall ||
        !syscallTable[header.sysnum].trustedProcess) {
      die("Trusted process encountered unexpected system call");
    }
    syscallTable[header.sysnum].trustedProcess(sandboxFd,
                                               iter->second.fdPub,
                                               iter->second.fd,
                                               iter->second.mem);
    if (header.sysnum == __NR_clone) {
      goto newThreadCreated;
    } else if (header.sysnum == __NR_exit) {
      NOINTR_SYS(sys.close(iter->second.fdPub));
      NOINTR_SYS(sys.close(iter->second.fd));
      threads.erase(iter);
    }
  }
}

void Sandbox::initializeProtectedMap(int fd) {
  // Read the memory mappings as they were before the sandbox takes effect.
  // These mappings cannot be changed by the sandboxed process.
  int mapsFd, shmFd;
  if (!getFd(fd, &mapsFd, &shmFd, NULL, NULL)) {
 maps_failure:
    die("Cannot access /proc/self/maps");
  }
  SysCalls sys;
  #ifdef __NR_mmap2
    #define MMAP mmap2
  #else
    #define MMAP mmap
  #endif
  void* page = sys.MMAP(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, shmFd,0);
  if (page == MAP_FAILED) {
    die("Cannot create shared memory");
  }
  syscall_mutex_ = reinterpret_cast<mutex_t*>(page);
  NOINTR_SYS(sys.close(shmFd));
  char line[80];
  FILE *fp = fdopen(mapsFd, "r");
  for (bool truncated = false;;) {
    if (fgets(line, sizeof(line), fp) == NULL) {
      if (feof(fp) || errno != EINTR) {
        break;
      }
      continue;
    }
    if (!truncated) {
      unsigned long start, stop;
      char *ptr = line;
      errno = 0;
      start = strtoul(ptr, &ptr, 16);
      if (errno || *ptr++ != '-') {
     parse_failure:
        die("Failed to parse /proc/self/maps");
      }
      stop = strtoul(ptr, &ptr, 16);
      if (errno || *ptr++ != ' ') {
        goto parse_failure;
      }
      protectedMap_[reinterpret_cast<void *>(start)] = stop - start;
    }
    truncated = strchr(line, '\n') == NULL;
  }
  NOINTR_SYS(sys.close(mapsFd));
  if (write(sys, fd, &mapsFd, sizeof(mapsFd)) != sizeof(mapsFd)) {
    goto maps_failure;
  }
}

void Sandbox::createTrustedProcess(int processFdPub, int sandboxFd,
                                   int cloneFdPub, int cloneFd){
  // Create a trusted process that can evaluate system call parameters and
  // decide whether a system call should execute. This process runs outside of
  // the seccomp sandbox. It communicates with the sandbox'd process through
  // a socketpair() and through securely shared memory.
  SysCalls sys;
  pid_t pid       = fork();
  if (pid < 0) {
    die("Failed to create trusted process");
  }
  if (!pid) {
    // Close all file handles except for sandboxFd, cloneFd, and stdio
    DIR *dir      = opendir("/proc/self/fd");
    if (dir == 0) {
      // If we don't know the list of our open file handles, just try closing
      // all valid ones.
      for (int fd = sysconf(_SC_OPEN_MAX); --fd > 2; ) {
        if (fd != sandboxFd && fd != cloneFd) {
          close(fd);
        }
      }
    } else {
      // If available, if is much more efficient to just close the file
      // handles that show up in /proc/self/fd/
      struct dirent de, *res;
      while (!readdir_r(dir, &de, &res) && res) {
        if (res->d_name[0] < '0')
          continue;
        int fd  = atoi(res->d_name);
        if (fd > 2 && fd != sandboxFd && fd != cloneFd && fd != dirfd(dir)) {
          close(fd);
        }
      }
      closedir(dir);
    }

    initializeProtectedMap(sandboxFd);
    trustedProcess(processFdPub, sandboxFd, cloneFdPub, cloneFd);
    die();
  }
  close(sandboxFd);
  close(cloneFd);
}

} // namespace
